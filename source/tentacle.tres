[gd_resource type="Shader" format=2]

[resource]
code = "shader_type canvas_item;

uniform sampler2D vertices_array; 
uniform int row_count;
uniform int col_count;

uniform vec4 color_outline: hint_color;
uniform vec4 color_shadow: hint_color;
uniform vec4 color_tentacle: hint_color; 
uniform vec4 color_suction: hint_color; 

const float width_start = 30.0;
const float width_end = 10.0;


vec2 from_vertices(float r, float c)
{
	return texture(vertices_array, vec2(c, r)).xy;
}


float lerp(float a, float b, float t)
{
	return a + t * (b - a);
}


vec2 point_on_line(vec2 a, vec2 b, vec2 p)
{
	vec2 ab = b - a; 
	vec2 ap = p - a;
	
	float ab_ap = dot(ap, ab);
	float ab_ab = dot(ab, ab); 
	
	float d = ab_ap / ab_ab;
	
	if (d <= 0.0) return a;
	if (d >= 1.0) return b;
	
	return a + d * ab;
}


float distance_to_line(vec2 a, vec2 b, vec2 p)
{
	vec2 pl = point_on_line(a, b, p);
	return length(pl - p);
}


float line_length(float r, vec2 pixel_size) 
{
	
	float total_length = 0.0;
	
	for (int c = 2; c < col_count + 1; ++c)
	{
		float cf = float(c) / float(col_count);
		vec2 a = from_vertices(r, cf - 1.0 * pixel_size.y);
		vec2 b = from_vertices(r, cf);
		
		total_length += length(b - a);
	}
	
	return total_length;
}


vec4 line_color(float r, vec2 point, vec2 pixel_size)
{
	vec4 color = vec4(0.0);
	
	float lt = line_length(r, pixel_size);
	float lc = 0.0;
	
	for (int c = 2; c < col_count + 1; ++c)
	{
		float cf = float(c) / float(col_count);
		vec2 a = from_vertices(r, cf - 1.0 * pixel_size.y);
		vec2 b = from_vertices(r, cf);

		vec2 pl = point_on_line(a, b, point);
		float dp = length(pl - point);
		float dpl = length(pl - a);
		
		float t = (lc + dpl) / lt;
		
		float w = lerp(width_start, width_end, t);
		if (dp < w - 10.0 )
		{
			color = color_tentacle;
		}
		if (dp < w - 5.0 && color != color_tentacle) 
		{
			color = color_shadow;
		}
		if (dp < w && color == vec4(0.0)) 
		{
			color = color_outline;
		}
		
		lc += length(b - a);
	}
	
	for (int c = 2; c < col_count + 1; c += 3)
	{
		float cf = float(c) / float(col_count);
		vec2 a = from_vertices(r, cf);
		float d = length(point - a);
		
		if (4.0 < d && d < 7.0)
		{
			color = color_suction;
		} 
	}
	
	return color;
}


void fragment() 
{
	vec2 point = UV * vec2(1.0) / SCREEN_PIXEL_SIZE;
	
	vec4 color = vec4(0.0);
	
	// Loop over each rope
	for (int rope = 0; rope < row_count; rope++)
	{
		float rf = 1.0 - float(rope) * TEXTURE_PIXEL_SIZE.y;
		vec4 new_color = line_color(rf, point, SCREEN_PIXEL_SIZE);
		if (new_color.a != 0.0)
		{
			color = new_color;
			break;
		}
	}
	
	COLOR = color;
}"
