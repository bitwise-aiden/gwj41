[gd_resource type="Shader" format=2]

[resource]
code = "shader_type canvas_item;

uniform sampler2D vertices_array; 
uniform int array_count;

uniform vec4 color_outline: hint_color;
uniform vec4 color_shadow: hint_color;
uniform vec4 color_tentacle: hint_color; 
uniform vec4 color_suction: hint_color; 


vec4 from_vertices(int r, int c)
{
	return texelFetch(vertices_array, ivec2(c, r), 0);
}


float distance_to_line(vec2 a, vec2 b, vec2 p)
{
	vec2 ab = b - a;
	vec2 ap = p - a; 
	vec2 bp = p - b;
	
	float ab_ap = dot(ab, ap);
	float ab_bp = dot(ab, bp);
	
	if (ab_bp > 0.0)
	{
		return length(bp);
	}
	
	if (ab_ap < 0.0)
	{
		return length(ap);
	}
	
	float t = length(ab);
	return abs(ab.x * ap.y - ab.y * ap.x) / t;
}


void fragment() 
{
	vec2 p = UV * vec2(1280.0, 720.0);
	
	vec4 color = vec4(0.0);
	
	for (int r = 0; r < array_count; ++r)
	{
		int vertex_count = int(from_vertices(r, 0).x);
		
		for (int c = 2; c < vertex_count + 1; ++c)
		{
			vec2 a = from_vertices(r, c - 1).xy;
			vec2 b = from_vertices(r, c).xy;

			float d = distance_to_line(a, b, p);
			
			if (d < 10.0)
			{
				color = color_tentacle;
			}

			if (d < 15.0 && color != color_tentacle)
			{
				color = color_shadow;
			}

			if (d < 20.0 && color == vec4(0.0))
			{
				color = color_outline;
			}
		}
		
		for (int c = 1; c < vertex_count + 1; c += 3)
		{
			vec2 a = from_vertices(r, c).xy;
			float d = length(p - a);
			
			if (4.0 < d && d < 7.0)
			{
				color = color_suction;
			} 
		}
	}
	
	COLOR = color;
}"
