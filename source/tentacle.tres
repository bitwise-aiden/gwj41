[gd_resource type="Shader" format=2]

[resource]
code = "shader_type canvas_item;

uniform sampler2D vertices_array; 
uniform int row_count;
uniform int col_count;

uniform vec4 color_outline: hint_color;
uniform vec4 color_shadow: hint_color;
uniform vec4 color_tentacle: hint_color; 
uniform vec4 color_suction: hint_color; 

const float width_start = 30.0;
const float width_end = 10.0;

vec2 from_vertices(int r, int c)
{
//	return texelFetch(vertices_array, ivec2(c, r), 0).xy;

//	float rs = trunc(10.0 / float(row_count)) / 10.0; 
//	float rf = float(r) * rs;
//
//	float cs = trunc(10.0 / float(col_count + 1)) / 10.0;
//	float cf = float(c) * cs;
	
	float rf = float(r) / float(row_count);
	float cf = float(c) / float(col_count + 1);
	
	return texture(vertices_array, vec2(cf, 1.0), 0).xy;
}


float lerp(float a, float b, float t)
{
	return a + t * (b - a);
}


vec2 point_on_line(vec2 a, vec2 b, vec2 p)
{
	vec2 ab = b - a; 
	vec2 ap = p - a;
	
	float ab_ap = dot(ap, ab);
	float ab_ab = dot(ab, ab); 
	
	float d = ab_ap / ab_ab;
	
	if (d <= 0.0) return a;
	if (d >= 1.0) return b;
	
	return a + d * ab;
}


float distance_to_line(vec2 a, vec2 b, vec2 p)
{
	vec2 pl = point_on_line(a, b, p);
	return length(pl - p);
}


float line_length(int r) 
{
	float total_length = 0.0;
	
	for (int c = 2; c < col_count + 1; ++c)
	{
		vec2 a = from_vertices(r, c - 1);
		vec2 b = from_vertices(r, c);
		
		total_length += length(b - a);
	}
	
	return total_length;
}


vec4 line_color(int r, vec2 point)
{
	vec4 color = vec4(0.0);
	
	float lt = line_length(r);
	float lc = 0.0;
	
	for (int c = 2; c < col_count + 1; ++c)
	{
		vec2 a = from_vertices(r, c - 1);
		vec2 b = from_vertices(r, c);

		vec2 pl = point_on_line(a, b, point);
		float dp = length(pl - point);
		float dpl = length(pl - a);
		
		float t = (lc + dpl) / lt;
		
		float w = lerp(width_start, width_end, t);
		if (dp < w - 10.0 )
		{
			color = color_tentacle;
		}
		if (dp < w - 5.0 && color != color_tentacle) 
		{
			color = color_shadow;
		}
		if (dp < w && color == vec4(0.0)) 
		{
			color = color_outline;
		}
		
		lc += length(b - a);
	}
	
	for (int c = 2; c < col_count + 1; c += 3)
	{
		vec2 a = from_vertices(r, c);
		float d = length(point - a);
		
		if (4.0 < d && d < 7.0)
		{
			color = color_suction;
		} 
	}
	
	return color;
}


void fragment() 
{
	vec2 point = UV * vec2(1.0) / SCREEN_PIXEL_SIZE;
	
	vec4 color = vec4(0.0);
	
	// Loop over each rope
	for (int rope = 0; rope < row_count; rope++)
	{
		vec4 new_color = line_color(rope, point);
		if (new_color.a != 0.0)
		{
			color = new_color;
			break;
		}
	}
	
	COLOR = color;
}"
